pub mod aux {
    use std::array::from_fn;
    use std::collections::HashMap;
    use std::hash::Hash;

    /// Check whether an n-dimensional index is within bounds of an n-dimensional shape.
    /// 
    /// Returns `Some` with the index as a `Box<[usize]>` if the index is within bounds, and `None` otherwise.
    /// 
    /// # Example
    /// 
    /// ```
    /// use aoc::aux::within_bounds;
    /// 
    /// let shape = [3, 4, 5];
    /// assert_eq!(within_bounds(&[0, 0, 0], &shape), Some(Box::new([0, 0, 0])));
    /// assert_eq!(within_bounds(&[2, 3, 4], &shape), Some(Box::new([2, 3, 4])));
    /// assert_eq!(within_bounds(&[3, 0, 0], &shape), None);
    /// assert_eq!(within_bounds(&[1, -1, 0], &shape), None);
    /// ```
    pub fn within_bounds<const DIM: usize>(index: [isize; DIM], shape: [usize; DIM]) -> Option<[usize; DIM]> {
        let mut index_unsigned: [usize; DIM] = from_fn(|i| index[i] as usize);
        for (i, (&x, &s)) in index.iter().zip(shape.iter()).enumerate() {
            if x < 0 || x as usize >= s {
                return None;
            }
            index_unsigned[i] = x as usize;
        }
        Some(index_unsigned.into())
    }

    /// Find the first repetition in a sequence of values.
    /// 
    /// The function `f` is first applied to the initial value `start` and then recursively to the result of the previous application.
    /// 
    /// Returns a tuple `(i, history)` where `i` is the index of the first occurrence of the repeating value in `history` and `history` is the sequence of values generated by `f`, including the starting value, but excluding the first repeated value.
    /// Specifically, it is always true that `f(&history.last().unwrap()) == history[i]`.
    /// 
    /// # Example
    /// 
    /// ```
    /// use aoc::aux::until_repeat;
    /// 
    /// let start = 0;
    /// let f = |x| (x + 1) % 5;
    /// let (i, history) = until_repeat(&start, f);
    /// assert_eq!(i, 0);
    /// assert_eq!(&history[..], &[0, 1, 2, 3, 4]);
    /// 
    /// let start = 7;
    /// let f = |x| (x + 1) % 3;
    /// let (i, history) = until_repeat(&start, f);
    /// assert_eq!(i, 1);
    /// assert_eq!(&history[..], &[7, 2, 0, 1]);
    /// ```
    pub fn until_repeat<T>(start: &T, f: fn(&T) -> T) -> (usize, Box<[T]>) where T: Clone + Eq + Hash {
        let mut seen_map: HashMap<T, usize> = HashMap::new();
        let mut seen_vec: Vec<T> = Vec::new();
        let mut current = start.clone();
        seen_map.insert(start.clone(), 0);
        seen_vec.push(start.clone());
        for t in 1.. {
            current = f(&current);
            if seen_map.get(&current).is_some() {
                break;
            }
            seen_map.insert(current.clone(), t);
            seen_vec.push(current.clone());
        }
        let rep_index = seen_map.get(&current).unwrap();
        (*rep_index, seen_vec.into_boxed_slice())
    }
}
